/*
 * ip_functions.c
 *
 * Contains all functions which pertain to setup and use of IP periperals.
 */

#include "adventures_with_ip.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "xil_printf.h"

#include "xil_types.h"
#include "xstatus.h"
#include "xscugic.h"
#include "ff.h"
#include "xparameters.h"


#define fatalError(msg) throwFatalError(__PRETTY_FUNCTION__,msg)

void throwFatalError(const char *func,const char *msg) {
	printf("%s() : %s\r\n",func,msg);
	for(;;);
}

// Size of the buffer which holds the DMA Buffer Descriptors (BDs)
#define DMA_BDUFFERSIZE 4000

FATFS FS_instance;
adau1761_config codec;

// This holds the memory allocated for the wav file currently played.
u8 *theBuffer = NULL;
size_t theBufferSize = 0;
int theVolume = 2;

typedef struct {
	char riff[4];
	u32 riffSize;
	char wave[4];
} headerWave_t;

typedef struct {
	char ckId[4];
	u32 cksize;
} genericChunk_t;

typedef struct {
	u16 wFormatTag;
	u16 nChannels;
	u32 nSamplesPerSec;
	u32 nAvgBytesPerSec;
	u16 nBlockAlign;
	u16 wBitsPerSample;
	u16 cbSize;
	u16 wValidBitsPerSample;
	u32 dwChannelMask;
	u8 SubFormat[16];
} fmtChunk_t;

void stopWavFile() {
    // If there was already a WAV file, free the memory
    if (theBuffer){
    	free(theBuffer);
    	theBuffer = NULL;
    	theBufferSize = 0;
    }
}

void playWavFile(const char *filename) {
    headerWave_t headerWave;
    fmtChunk_t fmtChunk;
    FIL file;
    UINT nBytesRead=0;

    stopWavFile();

    FRESULT res = f_open(&file, filename, FA_READ);
    if (res!=0) {
    	fatalError("File not found");
    }
    printf("Loading %s\r\n",filename);

    // Read the RIFF header and do some basic sanity checks
    res = f_read(&file,(void*)&headerWave,sizeof(headerWave),&nBytesRead);
    if (res!=0) {
    	fatalError("Failed to read file");
    }
	if (memcmp(headerWave.riff,"RIFF",4)!=0) {
		fatalError("Illegal file format. RIFF not found");
	}
	if (memcmp(headerWave.wave,"WAVE",4)!=0) {
		fatalError("Illegal file format. WAVE not found");
	}

	// Walk through the chunks and interpret them
	for(;;) {
		// read chunk header
		genericChunk_t genericChunk;
		res = f_read(&file,(void*)&genericChunk,sizeof(genericChunk),&nBytesRead);
		if (res!=0) {
			fatalError("Failed to read file");
		}
		if (nBytesRead!=sizeof(genericChunk)) {
			break; // probably EOF
		}

		// The "fmt " is compulsory and contains information about the sample format
		if (memcmp(genericChunk.ckId,"fmt ",4)==0) {
			res = f_read(&file,(void*)&fmtChunk,genericChunk.cksize,&nBytesRead);
			if (res!=0) {
				fatalError("Failed to read file");
			}
			if (nBytesRead!=genericChunk.cksize) {
				fatalError("EOF reached");
			}
			if (fmtChunk.wFormatTag!=1) {
				fatalError("Unsupported format");
			}
			if (fmtChunk.nChannels!=2) {
				fatalError("Only stereo files supported");
			}
			if (fmtChunk.wBitsPerSample!=16) {
				fatalError("Only 16 bit per samples supported");
			}
		}
		// the "data" chunk contains the audio samples
		else if (memcmp(genericChunk.ckId,"data",4)==0) {
		    theBuffer = malloc(genericChunk.cksize);
		    if (!theBuffer){
		    	fatalError("Could not allocate memory");
		    }
		    theBufferSize = genericChunk.cksize;

		    res = f_read(&file,(void*)theBuffer,theBufferSize,&nBytesRead);
		    if (res!=0) {
		    	fatalError("Failed to read file");
		    }
		    if (nBytesRead!=theBufferSize) {
		    	fatalError("Didn't read the complete file");
		    }
		}
		// Unknown chunk: Just skip it
		else {
			DWORD fp = f_tell(&file);
			f_lseek(&file,fp + genericChunk.cksize);
		}
	}

	// If we have data to play
    if (theBuffer) {
        printf("Playing %s\r\n",filename);

        // Crude in-place down-sampling: Basically taking every n'th of a sample
        // Jerobeam Fenderson's WAV files use a sampling rate of 192kHz (https://oscilloscopemusic.com)
        // Our sampling rate is actually 39.0625, so a 44.1kHz file will play a at 88.5% the speed (and lower in pitch).
    	double subSample = (double)fmtChunk.nSamplesPerSec/44100;
    	if (subSample>1.6) {
    		int skip = (int)(subSample+0.5);
    		u32 nNewTotal = theBufferSize/4/skip;
    		u32 *pSource = (u32*) theBuffer;
    		u32 *pDest = (u32*) theBuffer;
    		for(u32 i=0;i<nNewTotal;++i,pSource+=skip,pDest++) {
    			*pDest = *pSource;
    		}
    		theBufferSize = nNewTotal*4;
    	}

    	// Changing the volume and swap left/right channel and polarity
    	{
    		u32 *pSource = (u32*) theBuffer;
    		for(u32 i=0;i<theBufferSize/4;++i) {
    			short left  = (short) ((pSource[i]>>16) & 0xFFFF);
    			short right = (short) ((pSource[i]>> 0) & 0xFFFF);
    			int left_i  = -(int)left * theVolume / 4;
    			int right_i = -(int)right * theVolume / 4;
    			if (left>32767) left = 32767;
    			if (left<-32767) left = -32767;
    			if (right>32767) right = 32767;
    			if (right<-32767) right = -32767;
    			left = (short)left_i;
    			right = (short)right_i;
    			pSource[i] = ((u32)right<<16) + (u32)left;
    		}
    	}
    }

    f_close(&file);
}

/* ---------------------------------------------------------------------------- *
 * 								audio_stream()									*
 * ---------------------------------------------------------------------------- *
 * This function performs audio loopback streaming by sampling the input audio
 * from the codec and then immediately passing the sample to the output of the
 * codec.
 *
 * The main menu can be accessed by entering 'q' on the keyboard.
 * ---------------------------------------------------------------------------- */
void audio_stream() {
    u32 in_left, in_right;

    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        // Read audio input from codec
        in_left = Xil_In32(I2S_DATA_RX_L_REG);
        in_right = Xil_In32(I2S_DATA_RX_R_REG);
        // Write audio output to codec
        Xil_Out32(I2S_DATA_TX_L_REG, in_left);
        Xil_Out32(I2S_DATA_TX_R_REG, in_right);
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q')
        menu();
    else
        audio_stream();
}  // audio_stream()

/* ---------------------------------------------------------------------------- *
 * 								gpio_initi()									*
 * ---------------------------------------------------------------------------- *
 * Initialises the GPIO driver for the push buttons and switches.
 * ---------------------------------------------------------------------------- */
unsigned char gpio_init() {
    int status;

    // Initialise Push Buttons
    status = XGpio_Initialize(&Gpio, BUTTON_SWITCH_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Set all switches direction to inputs
    XGpio_SetDataDirection(&Gpio, SWITCH_CHANNEL, 0xFF);

    // Set all buttons direction to inputs
    XGpio_SetDataDirection(&Gpio, BUTTON_CHANNEL, 0xFF);

    return XST_SUCCESS;
}

/* ---------------------------------------------------------------------------- *
 * 								lab_test()									    *
 * ---------------------------------------------------------------------------- *
Audio: This task will have you build off of the audio tutorial so that you are
able to record sounds to memory and play them back over a speaker.

You should be able to start and stop a recording (up to a fixed time length) as
well as play it back with user input (key press/push button/etc).

Be prepared to answer questions on your final implementation and design choices.

Note: Your user interface (push buttons/switches/key press/etc.) will need to
use interrupts to get full marks and not polling.

Remember, the use of interrupts is a requirement for your final project, so it
would be good if at least one of you could use this as the basis of for one of your
project milestones to help you succeed with your final project deliverables.
 * ---------------------------------------------------------------------------- */
int lab_test() {
    u32 audio_buffer_left[BUFFER_SIZE*sizeof(u32)];
    u32 audio_buffer_right[BUFFER_SIZE*sizeof(u32)];
	//unsigned char *buffer;
    int buffer_index = 1;
    u32 in_left;
    u32 in_right;
    int print_record_status = 0;
    int print_play_status = 0;
    int print_standby_status = 0;
    int i = 0;
    COMM_VAL = 0;

    // Load audio from SD card
    load_audio();

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue. */
    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        // Recording mode
        if (COMM_VAL == 1) {
            if (print_record_status == 0) {
                xil_printf("Recording...\r\n");
                print_record_status = 1;
            }
            // Read audio input from codec
            in_left = Xil_In32(I2S_DATA_RX_L_REG);
            audio_buffer_left[buffer_index] = in_left;
            in_right = Xil_In32(I2S_DATA_RX_R_REG);
            audio_buffer_right[buffer_index] = in_right;
            // Write audio output to codec
            Xil_Out32(I2S_DATA_TX_L_REG, audio_buffer_left[buffer_index]);
            Xil_Out32(I2S_DATA_TX_R_REG, audio_buffer_right[buffer_index]);
            buffer_index++;
            print_play_status = 0;
            print_standby_status = 0;
        }
        // Playback mode
        else if (COMM_VAL == 2 && i < buffer_index) {
            if (print_play_status == 0) {
                xil_printf("Playing...\r\n");
                print_play_status = 1;
                print_record_status = 0;
                print_standby_status = 0;
            }
            // Write audio output to codec
            if (i % 3 == 0) {
            	usleep(1);
            }

			Xil_Out32(I2S_DATA_TX_L_REG, audio_buffer_left[i]);
			Xil_Out32(I2S_DATA_TX_R_REG, audio_buffer_right[i]);

            i++;
        }
        // Standby mode
        else if (COMM_VAL == 3) {
            if (print_standby_status == 0) {
                xil_printf("Standby...\r\n");
                print_standby_status = 1;
            }
            print_record_status = 0;
            print_play_status = 0;
        }
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q') {
        menu();
    } else {
        lab_test();
    }
    return XST_SUCCESS;
}

void load_audio() {
    init_platform();

    setvbuf(stdin, NULL, _IONBF, 0);
    print("WAV File Player\n\r");

    for(;;) {
        print("Mounting SD Card\n\r");
		FRESULT result = f_mount(&FS_instance,"0:/", 1);
		if (result != 0) {
			print("Couldn't mount SD Card. Press RETURN to try again\r\n");
			getchar();
			continue;
		}

		#define maxFiles 32
		char files[maxFiles][32] = {0};
		int filesNum = 0;

		// Look for *.wav files and copy file names to files[]
		DIR dir;
		FRESULT res = f_opendir(&dir, "0:/");
		if (res != FR_OK) {
			print("Couldn't read root directory. Press RETURN to try again\r\n");
			getchar();
			continue;
		}
		for (;;) {
			FILINFO fno;
			res = f_readdir(&dir, &fno);
			if (res != FR_OK || fno.fname[0] == 0) {
				break;
			}
			if (fno.fattrib & AM_DIR) {                 // It's a directory
			}
			else if (strstr(fno.fname,".wav")!=NULL || strstr(fno.fname,".WAV")!=NULL) { // It's a WAV file
				strcpy(files[filesNum++],fno.fname);
			}
			else {										// It's a normal file
			}
		}
		f_closedir(&dir);

		if (filesNum == 0) {
			print("No WAV files found. Press RETURN to try again\r\n");
			getchar();
			continue;
		}

		// Rudimentary user interface
		int currentFile = 0;
		for(;;) {
			printf("\033[2J\033[H");
			printf("[ VOL = %d%% ]\r\n",theVolume*100/4);
			for(int i=0;i<filesNum;++i) {
				printf("%c%s\r\n",i==currentFile ? '*' : ' ',files[i]);
			}
			printf("UP    : Previous file       LEFT:  Volume -\r\n");
			printf("DOWN  : Next file           RIGHT: Volume +\r\n");
			printf("RETURN: Play\r\n");
			printf("SPACE : New SD Card\r\n");

			int c = getchar();
			//printf("%02X\r\n",c);
			if (c==32) {
				stopWavFile();
				break;
			}
			switch(c) {
			case 13: 	playWavFile(files[currentFile]);
						break;
			case 0x5B:	c = getchar();
						//printf("D%02X\r\n",c);
						if (c==0x42) {
							if (currentFile+1<filesNum) {
								++currentFile;
							}
						}
						else if (c==0x41) {
							if (currentFile>0) {
								--currentFile;
							}
						}
						else if (c==0x44) {
							if (theVolume>1) {
								theVolume--;
							}
						}
						else if (c==0x43) {
							if (theVolume<16) {
								theVolume++;
							}
						}
			}
		}
    }

	print("Good bye\n\r");

    cleanup_platform();
    return 0;
}

