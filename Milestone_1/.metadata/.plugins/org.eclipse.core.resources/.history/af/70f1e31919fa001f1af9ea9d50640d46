/*
 * ip_functions.c
 *
 * Contains all functions which pertain to setup and use of IP periperals.
 */

#include "adventures_with_ip.h"

/* ---------------------------------------------------------------------------- *
 * 								audio_stream()									*
 * ---------------------------------------------------------------------------- *
 * This function performs audio loopback streaming by sampling the input audio
 * from the codec and then immediately passing the sample to the output of the
 * codec.
 *
 * The main menu can be accessed by entering 'q' on the keyboard.
 * ---------------------------------------------------------------------------- */
void audio_stream() {
    u32 in_left, in_right;

    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        // Read audio input from codec
        in_left = Xil_In32(I2S_DATA_RX_L_REG);
        in_right = Xil_In32(I2S_DATA_RX_R_REG);
        // Write audio output to codec
        Xil_Out32(I2S_DATA_TX_L_REG, in_left);
        Xil_Out32(I2S_DATA_TX_R_REG, in_right);
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q')
        menu();
    else
        audio_stream();
}  // audio_stream()

/* ---------------------------------------------------------------------------- *
 * 								gpio_initi()									*
 * ---------------------------------------------------------------------------- *
 * Initialises the GPIO driver for the push buttons and switches.
 * ---------------------------------------------------------------------------- */
unsigned char gpio_init() {
    int status;

    // Initialise Push Buttons
    status = XGpio_Initialize(&Gpio, BUTTON_SWITCH_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Set all switches direction to inputs
    XGpio_SetDataDirection(&Gpio, SWITCH_CHANNEL, 0xFF);

    // Set all buttons direction to inputs
    XGpio_SetDataDirection(&Gpio, BUTTON_CHANNEL, 0xFF);

    return XST_SUCCESS;
}

/* ---------------------------------------------------------------------------- *
 * 								lab_test()									    *
 * ---------------------------------------------------------------------------- *
Audio: This task will have you build off of the audio tutorial so that you are
able to record sounds to memory and play them back over a speaker.

You should be able to start and stop a recording (up to a fixed time length) as
well as play it back with user input (key press/push button/etc).

Be prepared to answer questions on your final implementation and design choices.

Note: Your user interface (push buttons/switches/key press/etc.) will need to
use interrupts to get full marks and not polling.

Remember, the use of interrupts is a requirement for your final project, so it
would be good if at least one of you could use this as the basis of for one of your
project milestones to help you succeed with your final project deliverables.
 * ---------------------------------------------------------------------------- */
int lab_test() {
    u32 audio_buffer_left[BUFFER_SIZE*sizeof(u32)];
    u32 audio_buffer_right[BUFFER_SIZE*sizeof(u32)];
	//unsigned char *buffer;
    int buffer_index = 1;
    u32 in_left;
    u32 in_right;
    int print_record_status = 0;
    int print_play_status = 0;
    int print_standby_status = 0;
    int i = 0;
    COMM_VAL = 0;


    //buffer = load_audio_file("beep.mp3");

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue. */
    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        // Recording mode
        if (COMM_VAL == 1) {
            if (print_record_status == 0) {
                xil_printf("Recording...\r\n");
                print_record_status = 1;
            }
            // Read audio input from codec
            in_left = Xil_In32(I2S_DATA_RX_L_REG);
            audio_buffer_left[buffer_index] = in_left;
            in_right = Xil_In32(I2S_DATA_RX_R_REG);
            audio_buffer_right[buffer_index] = in_right;
            // Write audio output to codec
            Xil_Out32(I2S_DATA_TX_L_REG, audio_buffer_left[buffer_index]);
            Xil_Out32(I2S_DATA_TX_R_REG, audio_buffer_right[buffer_index]);
            buffer_index++;
            print_play_status = 0;
            print_standby_status = 0;
        }
        // Playback mode
        else if (COMM_VAL == 2 && i < buffer_index) {
            if (print_play_status == 0) {
                xil_printf("Playing...\r\n");
                print_play_status = 1;
                print_record_status = 0;
                print_standby_status = 0;
            }
            // Write audio output to codec
            if (i % 3 == 0) {
            	usleep(1);
            }

			Xil_Out32(I2S_DATA_TX_L_REG, audio_buffer_left[i]);
			Xil_Out32(I2S_DATA_TX_R_REG, audio_buffer_right[i]);

            i++;
        }
        // Standby mode
        else if (COMM_VAL == 3) {
            if (print_standby_status == 0) {
                xil_printf("Standby...\r\n");
                print_standby_status = 1;
            }
            print_record_status = 0;
            print_play_status = 0;
        }
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q') {
        menu();
    } else {
        lab_test();
    }
    return XST_SUCCESS;
}

void load_audio() {
	FILE *file = fopen(fileName, "rb");
	if (!file) {
		perror("Error opening file");
		return NULL;
	}

	fseek(file, 0, SEEK_END);
	rewind(file);

	unsigned char *buffer = (unsigned char*)malloc(1000);
	if (!buffer) {
		perror("Malloc failed");
		fclose(file);
		return NULL;
	}

	fread(buffer, 1, 1000, file);
	fclose(file);

	return buffer;
}

