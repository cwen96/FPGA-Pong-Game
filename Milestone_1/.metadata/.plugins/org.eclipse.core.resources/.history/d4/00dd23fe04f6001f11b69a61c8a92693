#include "game.h"

Game::Game(int mode){
	score[0]=0;
	score[1]=0;
	ballLocationX = 1150;
	ballLocationY = 200;
	ballXVelocity = 1;
	ballYVelocity = 5;
	leftPaddleLocation = 400;
	rightPaddleLocation = 400;
	rightPaddleVelocity = 0;
	leftPaddleVelocity = 0;
	if(mode == 1){
		//initialize computer player
	}
}

void Game::resetBall(){
	ballLocationX = 620;
	ballLocationY = 492;
}

void Game::awardPoint(int player){
	score[player]++;
	//check victory condition
	if(score[player] == 11){
		//display Player x wins to screen, record and end game
	}
}

void Game::checkWallCollision(){//check if on next frame ball will contact wall, then handle if so
	if(ballYVelocity>0){//ball velocity is positive i.e moving down
		// If the velocity of the ball is greater than the distance from the bottom of the ball to the bottom of the screen, collision next frame
		if(SCREEN_HEIGHT-BALL_DIAMETER-ballLocationY < ballYVelocity){
			ballYVelocity = ballYVelocity*(-1);
			//TODO:write collision flag to shared memory for sound to play
		}
	}else{
		//ball velocity is negative. If |ball velocity| > distance of ball to wall, collision next frame
		if((-1)*ballYVelocity > ballLocationY) {
			ballYVelocity = ballYVelocity*(-1);
			//TODO:write collision flag to shared memory for sound to play
		}
	}
}

void Game::checkPaddleCollision(){//TODO:fix collision for top and bottom of paddles

	if(ballXVelocity >= 0){//moving right, check collision with right paddle
		//check for collision with top of paddle
		//check if right side of ball has passed the face of the paddle
		if(ballLocationX + BALL_DIAMETER > (SCREEN_WIDTH - PADDLE_GAP_FROM_EDGE - PADDLE_WIDTH) ){
			xil_printf("past first if\r\n");
			//if moving down while above paddle and the space between the bottom of the ball and top of paddle is less than y velocity, invert y velocity
			if(ballYVelocity > 0 && (rightPaddleLocation - (ballLocationY + BALL_DIAMETER)) < ballYVelocity){
				ballYVelocity = ballYVelocity*(-1);
			}
//			//moving up and space between top of ball and bottom of paddle less than -ve y velocity, invert y velocity
//			}else if (ballYVelocity < 0 && (rightPaddleLocation+PADDLE_HEIGHT - (ballLocationY)) > ballYVelocity*(-1)){
//				ballYVelocity = ballYVelocity*(-1);
//			}
		}
		//ball velocity means that in the next frame the ball will contact the paddle
		else if(ballXVelocity > (SCREEN_WIDTH - PADDLE_WIDTH - PADDLE_GAP_FROM_EDGE-(ballLocationX + BALL_DIAMETER))){
			xil_printf("passing return threshhold\r\n");
			if(ballLocationY > rightPaddleLocation - BALL_DIAMETER && ballLocationY < rightPaddleLocation + PADDLE_HEIGHT){
				xil_printf("returning ball\r\n");
				ballXVelocity = (ballXVelocity+2)*(-1);
				//when contacting paddle, new ball velocity should be set to a function of how far the center of the ball is from the center of the paddle
				//as if the paddle were actually a convex surface
				ballYVelocity=(ballLocationY+(BALL_DIAMETER/2)-(rightPaddleLocation+(PADDLE_HEIGHT/2)))/4;
			}
		}
	}else{
		if(ballXVelocity < ((PADDLE_WIDTH + PADDLE_GAP_FROM_EDGE) - ballLocationX)){//ball velocity is higher than distance to paddle i.e. will contact in next frame
			xil_printf("collision next frame\r\n");
			if(ballLocationY > leftPaddleLocation-BALL_DIAMETER && ballLocationY < leftPaddleLocation+PADDLE_HEIGHT){
				ballXVelocity = (ballXVelocity+2)*(-1);//increase x velocity and invert direction

				//TODO:adjust Y velocity depending on where the ball contacted paddle
				ballYVelocity=(ballLocationY+(BALL_DIAMETER/2)-(leftPaddleLocation+(PADDLE_HEIGHT/2)))/4;
			}
		}
	}
}
void Game::updateGameState(){
		checkWallCollision();
		checkPaddleCollision();
		ballLocationX = ballLocationX+ballXVelocity;
		ballLocationY = ballLocationY+ballYVelocity;

	}
