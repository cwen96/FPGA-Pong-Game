#include "game.h"
#include <algorithm>
Game::Game(int mode, int difficulty) {
    score[0] = 0;
    score[1] = 0;
    *ballDiameterReg = BALL_DIAMETER;
    *paddleHeightReg = PADDLE_HEIGHT;
    *paddleWidthReg = PADDLE_WIDTH;
    *paddleLeftXLocation = PADDLE_GAP_FROM_EDGE;
    *paddleRightXLocation= (SCREEN_WIDTH-PADDLE_GAP_FROM_EDGE-PADDLE_WIDTH);
    *leftPaddleLocationReg = 400;
    *rightPaddleLocationReg = 400;

    difficulty = difficulty;
    ballLocationX = 1000;
    ballLocationY = 200;
    ballXVelocity = 10;
    ballYVelocity = -3;
    leftPaddleLocation = 400;
    rightPaddleLocation = 400;
    rightPaddleVelocity = 0;
    leftPaddleVelocity = 0;
    if (mode == 1) {
        // initialize computer player
    }
}
void Game::setMode(int newMode){
	mode = newMode;
}

void Game::setDifficulty(int level){
	difficulty = level;
}
void Game::resetScore(){
	score[0]=0;
	score[1]=0;
}

int Game::checkWinner() {
    if (score[0] == 11) {
        xil_printf("player 1 wins!\n\r");
        return 1;
    } else if (score[1] == 11) {
        xil_printf("player 2 wins!\n\r");
        return 2;
    }
    // TODO:end the game
    return 0;
}
int Game::getPlayerOneScore(){
	return score[0];
}

int Game::getPlayerTwoScore(){
	return score[1];
}
int Game::checkPoint() {
    if (ballLocationX > 1400) {
    	//player 0 (left )gets a point if ball passes right edge of screen
        return 0;
        xil_printf("player 0 point\n");
    } else if (ballLocationX < -200) {
    	//player 1 (right) gets a point if ball passes left edge of screen
        return 1;
        xil_printf("player 1 point\n");
    } else {
    	//no points
        return -1;
    }
}
void Game::resetBall() {
    ballLocationX = 620;
    ballLocationY = 492;
    int randInt = Xil_In32(0x43C30000);
    if(randInt > 0){
    	ballXVelocity = INITIAL_X_VELOCITY[difficulty];
    }else{
    	ballXVelocity = -INITIAL_X_VELOCITY[difficulty];
    }

    ballYVelocity = randInt/10000000;
}

void Game::awardPoint(int player) {
    score[player]++;
    // check victory condition
    if (score[player] == 11) {
        // display Player x wins to screen, record and end game
    }
}

void Game::checkWallCollision() {  // check if on next frame ball will contact wall, then handle if so
    if (ballYVelocity > 0) {       // ball velocity is positive i.e moving down
        // If the velocity of the ball is greater than the distance from the bottom of the ball to the bottom of the screen, collision next frame
        if (SCREEN_HEIGHT - BALL_DIAMETER - ballLocationY < ballYVelocity) {
            ballYVelocity = ballYVelocity * (-1);
            // TODO:write collision flag to shared memory for sound to play
        }
    } else {
        // ball velocity is negative. If |ball velocity| > distance of ball to wall, collision next frame
        if ((-1) * ballYVelocity > ballLocationY) {
            ballYVelocity = ballYVelocity * (-1);
            // TODO:write collision flag to shared memory for sound to play
        }
    }
}

void Game::checkPaddleCollision() {  // TODO:fix collision for top and bottom of paddles
	 //moving right, check collision with right paddle
    if (ballXVelocity >= 0) {
    	//preliminary check to see if ball has already fully passed paddle, in which case stop checking for collision
    	if(ballLocationX < SCREEN_WIDTH - PADDLE_GAP_FROM_EDGE){
			// check if right side of ball has passed the face of the paddle i.e. no longer returnable, bounce off top of paddle
			if (ballLocationX + BALL_DIAMETER >= (SCREEN_WIDTH - PADDLE_GAP_FROM_EDGE - PADDLE_WIDTH) ){
				// if moving down while above paddle and the space between the bottom of the ball and top of paddle is less than y velocity, invert y velocity
				//xil_printf("passed paddle\n");
				//if ball will touch paddle in next frame,
				if (rightPaddleLocation - (ballLocationY + BALL_DIAMETER) <= (ballYVelocity - rightPaddleVelocity) && ballLocationY + BALL_DIAMETER <= rightPaddleLocation) {
					ballYVelocity = std::min(ballYVelocity * (-1), leftPaddleVelocity);
				}
				// below paddle and space between top of ball and bottom of paddle less than -ve y velocity, invert y velocity
				else if( ((ballLocationY - (rightPaddleLocation + PADDLE_HEIGHT) ) < (ballYVelocity * (-1) - rightPaddleVelocity)) && (ballLocationY >= rightPaddleLocation + PADDLE_HEIGHT)) {
					ballYVelocity = std::max(ballYVelocity * (-1), leftPaddleVelocity);
				}
			//if ball hasn't already passed the paddle face, check for a collision
			// ball velocity greater than distance to paddle means that in the next frame the ball will contact the paddle
			} else if (ballLocationX < (SCREEN_WIDTH - PADDLE_GAP_FROM_EDGE - PADDLE_WIDTH) && ballXVelocity >= (SCREEN_WIDTH - PADDLE_WIDTH - PADDLE_GAP_FROM_EDGE - (ballLocationX + BALL_DIAMETER))) {

				if ((ballLocationY + BALL_DIAMETER > rightPaddleLocation) && (ballLocationY < rightPaddleLocation + PADDLE_HEIGHT)) {
					// xil_printf("returning ball\r\n");
					ballXVelocity = (ballXVelocity + 2) * (-1);
					// when contacting paddle, new ball velocity should be set to a function of how far the center of the ball is from the center of the paddle
					//(with the paddle simulating a convex surface), as well as the current velocity of the ball and the speed of the paddle.
					ballYVelocity += ((rightPaddleVelocity / 4) + (ballLocationY + (BALL_DIAMETER / 2) - (rightPaddleLocation + (PADDLE_HEIGHT / 2))) / 10);
					// TODO:set flag to play sound for collision
				}
			}
		}
    //ball moving left, check left paddle
    } else {
    	if(ballLocationX + BALL_DIAMETER > PADDLE_GAP_FROM_EDGE){
    		if (ballLocationX + BALL_DIAMETER < (PADDLE_GAP_FROM_EDGE + PADDLE_WIDTH)) {

				// if moving down while above paddle and the space between the bottom of the ball and top of paddle is less than y velocity, invert y velocity
    			//top paddle collision
				if ((leftPaddleLocation - (ballLocationY + BALL_DIAMETER)) <= (ballYVelocity - leftPaddleVelocity) && ballLocationY + BALL_DIAMETER <= leftPaddleLocation) {
					ballYVelocity = std::min(ballYVelocity * (-1), leftPaddleVelocity);
				}
				// moving up and space between top of ball and bottom of paddle less than -ve y velocity, invert y velocity
				else if (ballYVelocity <= 0 && (leftPaddleLocation + PADDLE_HEIGHT - ballLocationY) <= (ballYVelocity * (-1) + leftPaddleVelocity) && ballLocationY <= leftPaddleLocation + PADDLE_HEIGHT) {
					ballYVelocity = std::max(ballYVelocity * (-1), leftPaddleVelocity);
				}
			// ball velocity greater than distance to paddle means that in the next frame the ball will contact the paddle
			} else if (ballXVelocity * (-1) >= (ballLocationX - (PADDLE_WIDTH + PADDLE_GAP_FROM_EDGE))) {  // ball velocity is higher than distance to paddle i.e. will contact in next frame

				if (ballLocationY > (leftPaddleLocation - BALL_DIAMETER) && ballLocationY < leftPaddleLocation + PADDLE_HEIGHT) {
					ballXVelocity = (ballXVelocity - 2) * (-1);  // increase x velocity and invert direction
					ballYVelocity += ((leftPaddleVelocity / 4) + (ballLocationY + (BALL_DIAMETER / 2) - (leftPaddleLocation + (PADDLE_HEIGHT / 2))) / 6);
					// TODO:set flag to play sound for collision
				}
			}
    	}

    }
}

int Game::updateGameState() {
	if(mode == 0){
		computerPlayer(100000000);
	}

    checkWallCollision();
    checkPaddleCollision();
    int point = checkPoint();

    if (point != -1) {
        awardPoint(point);
        xil_printf("P1: %d P2: %d\n", score[0], score[1]);
        int winner = checkWinner();
        resetBall();
        return winner;
    }

    ballLocationX = ballLocationX + ballXVelocity;
    ballLocationY = ballLocationY + ballYVelocity;
    *ballLocationYReg = ballLocationY;
    *ballLocationXReg = ballLocationX;

    //xil_printf("ball y location: %d\n",*ballLocationYReg);

    if (point != -1) {
            awardPoint(point);
            int winner = checkWinner();
            resetBall();
            return winner;
    }
    return 0;
}

void Game::movePaddle(int player, int velocity) {
    if (player == 0) {
    	if (leftPaddleLocation > SCREEN_HEIGHT-PADDLE_HEIGHT-10 && velocity > 0) {
    		 leftPaddleVelocity = 0;

    	}else if(leftPaddleLocation < 10 && velocity <0){
    		leftPaddleVelocity = 0;
    	}else{
    		leftPaddleVelocity = velocity;
    		leftPaddleLocation = leftPaddleLocation + velocity;
    		*leftPaddleLocationReg = leftPaddleLocation;
    	}
    }else if (player == 1) {
		if (rightPaddleLocation > SCREEN_HEIGHT-PADDLE_HEIGHT -10 && velocity > 0) {
			rightPaddleVelocity = 0;

		}else if(rightPaddleLocation < 10 && velocity <0){
			rightPaddleVelocity = 0;
		}else{
			rightPaddleVelocity = velocity;
			rightPaddleLocation = rightPaddleLocation + velocity;
			*rightPaddleLocationReg = rightPaddleLocation;
		}
	 }

}

void Game::paddleMovementHandler() {
    if (PLAYER_1_VELOCITY != 0) {
        movePaddle(0, PLAYER_1_VELOCITY);
    }
    if (PLAYER_2_VELOCITY != 0) {
        movePaddle(1, PLAYER_2_VELOCITY);
    }
}

void Game::computerPlayer(int difficulty){
	int randInt = Xil_In32(0x43C30000);
	if(randInt > abs(difficulty)){
		if(ballLocationY < (rightPaddleLocation +PADDLE_HEIGHT/2)){
			movePaddle(1, -PADDLE_SPEED);
		}else if (ballLocationY > (rightPaddleLocation + PADDLE_HEIGHT/2)){
			movePaddle(1, PADDLE_SPEED);
		}
	}
}
