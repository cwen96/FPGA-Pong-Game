// Empty C++ Application
#include <stdio.h>
#include <xil_cache.h>

#include <cstdlib>
#include <string>
#include "game.h"
#include "xgpio.h"
#include "xil_exception.h"
#include "xil_io.h"
#include "xil_mmu.h"
#include "xil_printf.h"
#include "xil_types.h"
#include "xparameters.h"
#include "xscugic.h"
#include "xtmrctr.h"
#include "addresses.h"
#define BLACK 0x000000
#define WHITE 0xF0F0F0
#define RED 0x0000F0
#define GREEN 0x00F000
#define BLUE 0xF00000
#define SCREEN_HEIGHT 1024
#define SCREEN_WIDTH 1280
#define BALL_DIAMETER 40
#define PADDLE_WIDTH 40
#define PADDLE_HEIGHT 250
#define sev() __asm__("sev")
#define ARM1_STARTADR 0xFFFFFFF0
#define ARM1_BASEADDR 0x10080000
#define COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))

// Parameter definitions
#define BTNS_DEVICE_ID XPAR_AXI_GPIO_1_DEVICE_ID
#define INTC_DEVICE_ID XPAR_PS7_SCUGIC_0_DEVICE_ID
// y
#define TMR_DEVICE_ID XPAR_TMRCTR_0_DEVICE_ID
// y
#define INTC_GPIO_INTERRUPT_ID XPAR_FABRIC_AXI_GPIO_1_IP2INTC_IRPT_INTR

#define INTC_TMR_INTERRUPT_ID XPAR_FABRIC_AXI_TIMER_0_INTERRUPT_INTR

#define BTN_INT XGPIO_IR_CH1_MASK
#define TMR_LOAD 0xFFE00000

XGpio LEDInst, BTNInst;
XScuGic INTCInst;
XTmrCtr TMRInst;

static int btn_value;

int recordStatus;

volatile bool TIMER_INTR_FLG;
volatile bool BUTTON_C_FLG= false;
volatile bool BUTTON_D_FLG= false;
volatile bool BUTTON_U_FLG= false;
volatile bool BUTTON_R_FLG= false;
volatile bool BUTTON_L_FLG= false;
int NUM_BYTES_BUFFER = 5242880;
//----------------------------------------------------
// PROTOTYPE FUNCTIONS
//----------------------------------------------------
static void BTN_Intr_Handler(void *baseaddr_p);
static void TMR_Intr_Handler(void *baseaddr_p);
static int InterruptSystemSetup(XScuGic *XScuGicInstancePtr);
static int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr);

//----------------------------------------------------
// INTERRUPT HANDLER FUNCTIONS
// - called by the timer, button interrupt, performs
// - LED flashing
//----------------------------------------------------

void BTN_Intr_Handler(void *InstancePtr) {
    // Disable GPIO interrupts
    XGpio_InterruptDisable(&BTNInst, BTN_INT);
    // Ignore additional button presses
    if ((XGpio_InterruptGetStatus(&BTNInst) & BTN_INT) !=
        BTN_INT) {
        return;
    }
    btn_value = XGpio_DiscreteRead(&BTNInst, 1);

    // Update paddle movement based on button value:
    // Left button (val == 4): move left paddle (player 1) up (-1)
    // Bottom button (val == 2): move left paddle (player 1) down (+1)
    // Top button (val == 8): move right paddle (player 2) up (-1)
    // Right button (val == 16): move right paddle (player 2) down (+1)
    if ((btn_value & 4) == 4) {
        PLAYER_1_VELOCITY = -PADDLE_SPEED;  // move player 1 up
        BUTTON_L_FLG = true;

    } else if ((btn_value & 2) == 2) {
        PLAYER_1_VELOCITY = PADDLE_SPEED;  // move player 1 down
        BUTTON_D_FLG = true;
    } else if ((btn_value & 8) == 8) {
        PLAYER_2_VELOCITY = PADDLE_SPEED;  // move player 2 up
        BUTTON_R_FLG = true;
    } else if ((btn_value & 16) == 16) {
        PLAYER_2_VELOCITY = -PADDLE_SPEED;  // move player 2 down
        BUTTON_U_FLG = true;

    }else if ((btn_value & 1) == 1) {
    	BUTTON_C_FLG=true;
    }else {
        // If none of these buttons are pressed, stop paddle movement.
        PLAYER_1_VELOCITY = 0;
        PLAYER_2_VELOCITY = 0;
    }

    (void)XGpio_InterruptClear(&BTNInst, BTN_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
}

void TMR_Intr_Handler(void *data) {
	TIMER_INTR_FLG = true;
	XTmrCtr_Reset(&TMRInst, 0);
	XTmrCtr_Start(&TMRInst, 0);
}

void displayColourBlock(int *baseAddr, int xloc, int yloc, int diam, int colour) {
    for (int i = 0; i < SCREEN_HEIGHT; i++) {
        for (int j = 0; j < SCREEN_WIDTH; j++) {
        	if (i > yloc && i < yloc + diam && j > xloc && j < xloc + diam){
        		baseAddr[i * SCREEN_WIDTH + j] = colour;
        	}
        }
    }
}

void writeBarsToScreen(int loopNum, int *baseAddr) {
    int COLOURS[] = {BLACK, WHITE, RED, GREEN, BLUE};
    for (int i = 0; i < SCREEN_HEIGHT; i++) {
        for (int j = 0; j < SCREEN_WIDTH; j++) {
            if (j < 256) {
                baseAddr[i * SCREEN_WIDTH + j] = COLOURS[loopNum % 5];
            } else if (j < 512) {
                baseAddr[i * SCREEN_WIDTH + j] = COLOURS[(loopNum + 1) % 5];
            } else if (j < 768) {
                baseAddr[i * SCREEN_WIDTH + j] = COLOURS[(loopNum + 2) % 5];
            } else if (j < 1024) {
                baseAddr[i * SCREEN_WIDTH + j] = COLOURS[(loopNum + 3) % 5];
            } else {
                baseAddr[i * SCREEN_WIDTH + j] = COLOURS[(loopNum + 4) % 5];
            }
        }
    }
}

int main(){
    xil_printf("Entering Main in core 0\r\n");
    int status;
    Xil_SetTlbAttributes(0x10080000, 0x14de2);
    Xil_Out32(ARM1_STARTADR, ARM1_BASEADDR);
    dmb();
    sev();
    int colours[5]={WHITE,BLACK,RED,BLUE,GREEN};
    //----------------------------------------------------
    // INITIALIZE THE PERIPHERALS & SET DIRECTIONS OF GPIO
    //----------------------------------------------------
    // Initialise Push Buttons
    status = XGpio_Initialize(&BTNInst, BTNS_DEVICE_ID);
    //	xil_printf("before return\r\n");
    if (status != XST_SUCCESS) return XST_FAILURE;
    //	xil_printf("after return\r\n");
    // Set LEDs direction to outputs
    //	XGpio_SetDataDirection(&LEDInst, 1, 0x00);
    // Set all buttons direction to inputs
    //	xil_printf("before setting the direction\r\n");
    XGpio_SetDataDirection(&BTNInst, 1, 0xFF);
    //	xil_printf("fater the gpio setup\r\n");

    //----------------------------------------------------
    // SETUP THE TIMER
    //----------------------------------------------------
    status = XTmrCtr_Initialize(&TMRInst, TMR_DEVICE_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;
    XTmrCtr_SetHandler(&TMRInst, (XTmrCtr_Handler)TMR_Intr_Handler, &TMRInst);
    XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD);
    XTmrCtr_SetOptions(&TMRInst, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);
    //	xil_printf("After the timer setup\r\n");

    // Initialize interrupt controller
    status = IntcInitFunction(INTC_DEVICE_ID, &TMRInst, &BTNInst);
    if (status != XST_SUCCESS) return XST_FAILURE;

    XTmrCtr_Start(&TMRInst, 0);

    // int loop = 0;
    int *image_buffer_pointer = (int *)0x00900000;
    int selectedBallColour = 0;
    int selectedPaddleColour =  0;
    bool menu = true;

    //menu flag, while menu is true, do menu stuff, while false, do game stuff


    int winner = 0;
    int mode = 0;
    int state = 0;
    int volume = 1;
    int gameHistory[9][2]={{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}};
    Game currentGame(0,0);
    while (1) {
        while (TIMER_INTR_FLG == false) {
            Xil_DCacheFlush();
        }
        if (menu){
        	switch(state){
        		case(0)://main menu single player highlighted
        			//setup buttons to switch state??
					memcpy(image_buffer_pointer, mainMenuSinglePlayer, NUM_BYTES_BUFFER);
        			//xil_printf("state %d\n", state);
        			if(BUTTON_D_FLG){
        				state = 1;
        			}else if(BUTTON_U_FLG){
        				state = 4;
        			}else if(BUTTON_R_FLG){
        				state = 5;
        				mode = 0;
        			}
        		    break;
        		case(1)://main menu multi player highlighted
					memcpy(image_buffer_pointer, mainMenuMultiPlayer, NUM_BYTES_BUFFER);
        			//xil_printf("state %d\n", state);
        			if(BUTTON_D_FLG){
        		        state = 2;
        		    }else if(BUTTON_U_FLG){
        		    	xil_printf("pressed up");
        		        state = 0;
        		    }else if(BUTTON_R_FLG){
        		    	state = 5;
        		    	mode = 1;
        			}
        		 	break;
        		case(2)://main menu volume highlighted
        			memcpy(image_buffer_pointer, mainMenuVolume, NUM_BYTES_BUFFER);
        			//xil_printf("state %d\n", state);
        			if(BUTTON_D_FLG){
        		    	state = 3;
        		    }else if(BUTTON_U_FLG){
        		    	state = 1;
        		    }else if(BUTTON_R_FLG){
        		    	if(volume == 1){
        		    		state = 8;
        		    	}else if(volume==2){
        		    		state = 9;
        		    	}else if (volume == 3){
        		    		state = 10;
        		    	}else {
        		    		state = 11;
        		    	}
        			}
        		    break;
        		case(3)://main menu game history highlighted
        			memcpy(image_buffer_pointer, mainMenuGameHistory, NUM_BYTES_BUFFER);
        			//xil_printf("state %d\n", state);
        			if(BUTTON_D_FLG){
        				state = 4;
        		    }else if(BUTTON_U_FLG){
        		    	state = 2;
        		    }else if(BUTTON_R_FLG){
        				state = (12);
        			}
        			break;
        		case(4)://main menu colour select highlighted
					memcpy(image_buffer_pointer, mainMenuColourSelect, NUM_BYTES_BUFFER);
        			//xil_printf("state %d\n", state);
        			if(BUTTON_D_FLG){
        				state = 0;
        		    }else if(BUTTON_U_FLG){
        		    	state = 3;
        		    }else if(BUTTON_R_FLG){
        				state = 13;
        				memcpy(image_buffer_pointer, ballColour, NUM_BYTES_BUFFER);
        				displayColourBlock(image_buffer_pointer,700, 300 , 200, colours[selectedBallColour%5]);
        				displayColourBlock(image_buffer_pointer,700, 550 , 200, colours[selectedPaddleColour%5]);

        			}
        		    break;
        		case(5)://select difficulty easy(both for single and multiplayer)
        			memcpy(image_buffer_pointer, difficultyEasy, NUM_BYTES_BUFFER);
        			if(BUTTON_D_FLG){
						state = 6;
					}else if(BUTTON_U_FLG){
						state = 7;
					}else if(BUTTON_R_FLG){
						xil_printf("pressed right");
						//start game easy
						memcpy(image_buffer_pointer, background, NUM_BYTES_BUFFER);

						menu = false;
						state = 0;
					}else if (BUTTON_L_FLG){
						state = 0;
					}
        			break;
        		case(6)://select difficulty medium
					memcpy(image_buffer_pointer, difficultyMedium, NUM_BYTES_BUFFER);
        			if(BUTTON_D_FLG){
						state = 7;
					}else if(BUTTON_U_FLG){
						state = 5;
					}else if(BUTTON_R_FLG){
						xil_printf("pressed right");
						//start game medium
						memcpy(image_buffer_pointer, background, NUM_BYTES_BUFFER);
						menu = false;
						state = 0;
					}else if (BUTTON_L_FLG){
						state = 0;
					}
        			break;
        		case(7)://select difficulty hard
					memcpy(image_buffer_pointer, difficultyHard, NUM_BYTES_BUFFER);
        			if(BUTTON_D_FLG){
						state = 5;
					}else if(BUTTON_U_FLG){
						state = 6;
					}else if(BUTTON_R_FLG){
						xil_printf("pressed right");
						//start game hard
						memcpy(image_buffer_pointer, background, NUM_BYTES_BUFFER);
						state = 0;
						menu = false;
					}else if (BUTTON_L_FLG){
						state = 0;
					}
        			break;
        		case(8)://volume 1
					memcpy(image_buffer_pointer, volume1, NUM_BYTES_BUFFER);
        			if(BUTTON_C_FLG){
        				state = 9;
        				volume = 2;
        			}else if (BUTTON_L_FLG){
        				state=2;
        			}
        			break;
        		case(9)://volume 2
					memcpy(image_buffer_pointer, volume2, NUM_BYTES_BUFFER);
					if(BUTTON_C_FLG){
						state = 10;
						volume = 3;
					}else if (BUTTON_L_FLG){
						state=2;
					}
					break;
        		case(10)://volume 3
					memcpy(image_buffer_pointer, volume3, NUM_BYTES_BUFFER);
					if(BUTTON_C_FLG){
						state=11;
						volume = 4;
					}else if (BUTTON_L_FLG){
						state=2;
					}
					break;
        		case(11)://volume 4
					memcpy(image_buffer_pointer, volume4, NUM_BYTES_BUFFER);
					if(BUTTON_C_FLG){
						state=8;
						volume = 1;
					}else if (BUTTON_L_FLG){
						state=2;
					}
        			break;
        		case(12)://game history
					memcpy(image_buffer_pointer, gameHistory, NUM_BYTES_BUFFER);
					if(BUTTON_L_FLG){
						state=3;
					}
					//TODO: print game history to screen
					break;
        		case(13)://select ball colour


					if(BUTTON_C_FLG){
						selectedBallColour++;
						displayColourBlock(image_buffer_pointer,700, 300 , 200, colours[selectedBallColour%5]);
						//cycle ball colour and save choice in register
					}else if (BUTTON_L_FLG){
						state = 4;
					}else if (BUTTON_D_FLG || BUTTON_U_FLG){
						state = 14;
						memcpy(image_buffer_pointer, paddleColour, NUM_BYTES_BUFFER);
						displayColourBlock(image_buffer_pointer,700, 300 , 200, colours[selectedBallColour%5]);
						displayColourBlock(image_buffer_pointer,700, 550 , 200, colours[selectedPaddleColour%5]);
					}
					break;
        		case(14)://select paddle colour

						if(BUTTON_C_FLG){
							selectedPaddleColour++;
							displayColourBlock(image_buffer_pointer,700, 550 , 200, colours[selectedPaddleColour%5]);
							//cycle paddle colour and store choice in register
						}else if (BUTTON_L_FLG){
							state = 4;
						}else if (BUTTON_D_FLG || BUTTON_U_FLG){
							state = 13;
							memcpy(image_buffer_pointer, ballColour, NUM_BYTES_BUFFER);
							displayColourBlock(image_buffer_pointer,700, 300 , 200, colours[selectedBallColour%5]);
							displayColourBlock(image_buffer_pointer,700, 550 , 200, colours[selectedPaddleColour%5]);
						}
						break;
        		default:
        			break;

        	}
        	BUTTON_R_FLG = false;
        	BUTTON_U_FLG = false;
        	BUTTON_D_FLG = false;
        	BUTTON_L_FLG = false;
        	BUTTON_C_FLG = false;
        }
        if (!menu){
        	currentGame.paddleMovementHandler();
        	winner = currentGame.updateGameState();
        	if(winner != 0){
        		menu = true;
        	}
        }
        //		xil_printf("in the original while loop\n");
        TIMER_INTR_FLG = false;



        //memcpy(image_buffer_pointer, image1_pointer, NUM_BYTES_BUFFER);

        // Process paddle movement from buttons

        //writeGameScreen(image1_pointer, currentGame.getLeftPaddleLocation(), currentGame.getRightPaddleLocation(), currentGame.getBallLocationX(), currentGame.getBallLocationY());

        //		if(loop == 0){
        //
        //			writeGameScreen(image1_pointer, 50, 400, 200, 600);
        //			memcpy(image_buffer_pointer, image1_pointer, NUM_BYTES_BUFFER);
        //		}
        //		else if(loop==1){
        //			writeGameScreen(image2_pointer, 300, 500, 0, 0);
        //			memcpy(image_buffer_pointer, image2_pointer, NUM_BYTES_BUFFER);
        //		}
        //		else if(loop==2){
        //			writeGameScreen(image3_pointer, 250, 550, 1200, 950);
        //			memcpy(image_buffer_pointer, image3_pointer, NUM_BYTES_BUFFER);
        //		}
        //		else if(loop==3){
        //			writeGameScreen(image4_pointer, 200, 600, 240, 300);
        //			memcpy(image_buffer_pointer, image4_pointer, NUM_BYTES_BUFFER);
        //		}
        //		else if(loop==4){
        //			writeGameScreen(image5_pointer, 600, 650, 500, 600);
        //			memcpy(image_buffer_pointer, image5_pointer, NUM_BYTES_BUFFER);
        //		}
        //		loop++;
        //		loop = loop % 5;
    }
    return 0;
}

//----------------------------------------------------
// INITIAL SETUP FUNCTIONS
//----------------------------------------------------

int InterruptSystemSetup(XScuGic *XScuGicInstancePtr) {
    // Enable interrupt
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
    XGpio_InterruptGlobalEnable(&BTNInst);

    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 XScuGicInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr) {
    XScuGic_Config *IntcConfig;
    int status;

    // Interrupt controller initialisation
    IntcConfig = XScuGic_LookupConfig(DeviceId);
    status = XScuGic_CfgInitialize(&INTCInst, IntcConfig, IntcConfig->CpuBaseAddress);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Call to interrupt setup
    status = InterruptSystemSetup(&INTCInst);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Connect GPIO interrupt to handler
    status = XScuGic_Connect(&INTCInst,
                             INTC_GPIO_INTERRUPT_ID,
                             (Xil_ExceptionHandler)BTN_Intr_Handler,
                             (void *)GpioInstancePtr);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Connect timer interrupt to handler
    status = XScuGic_Connect(&INTCInst,
                             INTC_TMR_INTERRUPT_ID,
                             (Xil_ExceptionHandler)TMR_Intr_Handler,
                             (void *)TmrInstancePtr);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Enable GPIO interrupts interrupt
    XGpio_InterruptEnable(GpioInstancePtr, 1);
    XGpio_InterruptGlobalEnable(GpioInstancePtr);

    // Enable GPIO and timer interrupts in the controller
    XScuGic_Enable(&INTCInst, INTC_GPIO_INTERRUPT_ID);

    XScuGic_Enable(&INTCInst, INTC_TMR_INTERRUPT_ID);

    return XST_SUCCESS;
}
