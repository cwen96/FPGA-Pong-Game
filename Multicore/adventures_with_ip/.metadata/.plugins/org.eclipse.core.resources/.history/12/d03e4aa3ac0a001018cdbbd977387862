#include <stdlib.h>
#include <math.h>
#include "xil_types.h"
#include "xstatus.h"
//#include "xllfifo.h"
#include "xscugic.h"
//#include "xaxidma.h"
#include "ff.h"
#include "audioSD.h"
#include "audio.h"

void throwFatalError(const char *func,const char *msg) {
	xil_printf("%s() : %s\r\n",func,msg);
	for(;;);
}

FATFS FS_instance;

// This holds the memory allocated for the wav file currently played.
u8 *theBuffer = NULL;
size_t theBufferSize = 0;
int theVolume = 2;

int currentFile = 0;
#define maxFiles 32
char files[maxFiles][32] = {0};
int filesNum = 0;

void stopWavFile() {
	// If there is already a WAV file playing, stop it
	//if (adau1761_dmaBusy(&codec)) {
	//	adau1761_dmaStop(&codec);
	//}
    // If there was already a WAV file, free the memory
    if (theBuffer){
//    	free(theBuffer);
//    	theBuffer = NULL;
//    	theBufferSize = 0;
    	void *temp = theBuffer;
    	theBuffer = NULL;
    	theBufferSize = 0;
    	free(temp);
    }
}

void playWavFile(const char *filename) {
    headerWave_t headerWave;
    fmtChunk_t fmtChunk;
    FIL file;
    UINT nBytesRead=0;

    stopWavFile();

    FRESULT res = f_open(&file, filename, FA_READ);
    if (res!=0) {
    	fatalError("File not found");
    }
    xil_printf("Loading %s\r\n",filename);

    // Read the RIFF header and do some basic sanity checks
    res = f_read(&file,(void*)&headerWave,sizeof(headerWave),&nBytesRead);
    if (res!=0) {
    	fatalError("Failed to read file");
    }
	if (memcmp(headerWave.riff,"RIFF",4)!=0) {
		fatalError("Illegal file format. RIFF not found");
	}
	if (memcmp(headerWave.wave,"WAVE",4)!=0) {
		fatalError("Illegal file format. WAVE not found");
	}

	// Walk through the chunks and interpret them
	for(;;) {
		// read chunk header
		genericChunk_t genericChunk;
		res = f_read(&file,(void*)&genericChunk,sizeof(genericChunk),&nBytesRead);
		if (res!=0) {
			fatalError("Failed to read file");
		}
		if (nBytesRead!=sizeof(genericChunk)) {
			break; // probably EOF
		}

		// The "fmt " is compulsory and contains information about the sample format
		if (memcmp(genericChunk.ckId,"fmt ",4)==0) {
			res = f_read(&file,(void*)&fmtChunk,genericChunk.cksize,&nBytesRead);
			if (res!=0) {
				fatalError("Failed to read file");
			}
			if (nBytesRead!=genericChunk.cksize) {
				fatalError("EOF reached");
			}
			if (fmtChunk.wFormatTag!=1) {
				fatalError("Unsupported format");
			}
			if (fmtChunk.nChannels!=2) {
				//fatalError("Only stereo files supported");
				 u32 *newBuffer = malloc(theBufferSize * 2);
				    if (!newBuffer) {
				        fatalError("Memory allocation failed for mono conversion");
				    }

				    // Convert mono to stereo (duplicate the same sample for both channels)
				    short *monoData = (short *)theBuffer;
				    u32 *stereoData = (u32 *)newBuffer;
				    u32 monoSamples = theBufferSize / 2; // Each sample is 2 bytes (16-bit PCM)

				    for (u32 i = 0; i < monoSamples; i++) {
				        short sample = monoData[i];
				        stereoData[i] = ((u32)sample << 16) | ((u32)sample & 0xFFFF);
				    }

				    // Free old buffer and update to the new stereo buffer
				    free(theBuffer);
				    theBuffer = (void *)newBuffer;
				    theBufferSize *= 2;
			}
			if (fmtChunk.wBitsPerSample!=16) {
				fatalError("Only 16 bit per samples supported");
				//continue;
			}
		}
		// the "data" chunk contains the audio samples
		else if (memcmp(genericChunk.ckId,"data",4)==0) {
		    theBuffer = malloc(genericChunk.cksize);
		    if (!theBuffer){
		    	fatalError("Could not allocate memory");
		    }
		    theBufferSize = genericChunk.cksize;

		    res = f_read(&file,(void*)theBuffer,theBufferSize,&nBytesRead);
		    if (res!=0) {
		    	fatalError("Failed to read file");
		    }
		    if (nBytesRead!=theBufferSize) {
		    	fatalError("Didn't read the complete file");
		    }
		}
		// Unknown chunk: Just skip it
		else {
			DWORD fp = f_tell(&file);
			f_lseek(&file,fp + genericChunk.cksize);
		}
	}

	// If we have data to play
    if (theBuffer) {
        xil_printf("Playing %s\r\n",filename);

        // Crude in-place down-sampling: Basically taking every n'th of a sample
        // Jerobeam Fenderson's WAV files use a sampling rate of 192kHz (https://oscilloscopemusic.com)
        // Our sampling rate is actually 39.0625, so a 44.1kHz file will play a at 88.5% the speed (and lower in pitch).
    	double subSample = (double)fmtChunk.nSamplesPerSec/441000;
    	if (subSample>1.6) {
    		int skip = (int)(subSample+0.5);
    		u32 nNewTotal = theBufferSize/4/skip;
    		u32 *pSource = (u32*) theBuffer;
    		u32 *pDest = (u32*) theBuffer;
    		for(u32 i=0;i<nNewTotal;++i,pSource+=skip,pDest++) {
    			*pDest = *pSource;
    		}
    		theBufferSize = nNewTotal*4;
    	}

    	// Changing the volume and swap left/right channel and polarity
    	{
    		u32 *pSource = (u32*) theBuffer;
    		for(u32 i=0;i<theBufferSize/4;++i) {
    			short left  = (short) ((pSource[i]>>16) & 0xFFFF);
    			short right = (short) ((pSource[i]>> 0) & 0xFFFF);
    			int left_i  = -(int)left * theVolume / 4;
    			int right_i = -(int)right * theVolume / 4;
    			if (left>32767) left = 32767;
    			if (left<-32767) left = -32767;
    			if (right>32767) right = 32767;
    			if (right<-32767) right = -32767;
    			left = (short)left_i;
    			right = (short)right_i;
    			pSource[i] = ((u32)right<<16) + (u32)left;

    			for(int i=0;i<1600;i++)
    				asm("NOP");
    			Xil_Out32(I2S_DATA_TX_L_REG, left*1000);
    			Xil_Out32(I2S_DATA_TX_R_REG, right*1000);
    		}
    	}

    	//adau1761_dmaTransmitBLOB(&codec, (u32*)theBuffer, theBufferSize/4);
    }

    f_close(&file);
}

void audioSD()
{
	 //init_platform();
		//clrscr();
	    setvbuf(stdin, NULL, _IONBF, 0);
	    xil_printf("WAV File Player\n\r");

		//print("Initializing ADAU1761\r\n");
	    //adau1761_init(&codec, XPAR_AXI_FIFO_MM_S_0_DEVICE_ID, XPAR_AXI_DMA_0_DEVICE_ID, XPAR_FABRIC_AXI_DMA_0_MM2S_INTROUT_INTR);

	    for(;;) {
	        xil_printf("Mounting SD Card\n\r");
			FRESULT result = f_mount(&FS_instance,"0:/", 1);
			if (result != 0) {
				xil_printf("Couldn't mount SD Card. Press RETURN to try again\r\n");
				getchar();
				continue;
			}

			//#define maxFiles 32
			int files[maxFiles][32] = {0};
			filesNum = 0;

			// Look for *.wav files and copy file names to files[]
			DIR dir;
			FRESULT res = f_opendir(&dir, "0:/");
			if (res != FR_OK) {
				xil_printf("Couldn't read root directory. Press RETURN to try again\r\n");
				getchar();
				continue;
			}

			for (;;) {
			    FILINFO fno;
			    res = f_readdir(&dir, &fno);
			    if (res != FR_OK || fno.fname[0] == 0) {
			        break;  // End of directory
			    }

			    if (fno.fattrib & AM_DIR) {
			        // It's a directory, ignore it
			    }
			    else if ((strstr(fno.fname, ".wav") != NULL || strstr(fno.fname, ".WAV") != NULL)
			             && fno.fname[0] != '_') {  // Ignore invalid filenames starting with '_'
			        strcpy(files[filesNum++], fno.fname);
			    }
			}


			f_closedir(&dir);

			if (filesNum == 0) {
				xil_printf("No WAV files found. Press RETURN to try again\r\n");
				getchar();
				continue;
			}

			// Rudimentary user interface
			currentFile = 0;
			for(;;) {
				xil_printf("\033[2J\033[H");
				xil_printf("[ VOL = %d%% ]\r\n",theVolume*100/4);
				for(int i=0;i<filesNum;++i) {
					xil_printf("%c%s\r\n",i==currentFile ? '*' : ' ',files[i]);
				}


				int c = getchar();
				// Handle number key inputs ('1' to '9')
				if (c >= '1' && c <= '9') {
				    int index = c - '1';  // Convert ASCII character to array index (0-based)
				    if (index < filesNum) {
				        playWavFile(files[index]);  // Play selected file
				    }
				}
				else if (c == 0x1B) { // SPACE key to refresh SD card
					xil_printf("Audio Stopped!!!\r\n");
					stopWavFile();

				    break;
				}
				else {
				    switch (c) {
				        case 13:  // ENTER key to play current file
				            playWavFile(files[currentFile]);
				            break;
				        case 0x5B:
				            c = getchar();
				            if (c == 0x42 && currentFile + 1 < filesNum) {
				                ++currentFile;
				            } else if (c == 0x41 && currentFile > 0) {
				                --currentFile;
				            } else if (c == 0x44 && theVolume > 1) {
				                theVolume--;
				            } else if (c == 0x43 && theVolume < 16) {
				                theVolume++;
				            }
				            break;
				    }
				}


			}
	    }

		//adau1761_dmaReset(&codec);

		xil_printf("Good bye\n\r");

	    //cleanup_platform();
	    //return 0;
}
