// Empty C++ Application
#include <stdio.h>
#include <xil_cache.h>

#include <cstdlib>
#include <string>

#include "addresses.h"
#include "drawings.h"
#include "game.h"
#include "xgpio.h"
#include "xil_exception.h"
#include "xil_io.h"
#include "xil_mmu.h"
#include "xil_printf.h"
#include "xil_types.h"
#include "xparameters.h"
#include "xscugic.h"
#include "xtmrctr.h"
#define BLACK 0x000000
#define WHITE 0xF0F0F0
#define RED 0x0000F0
#define GREEN 0x00F000
#define BLUE 0xF00000
#define SCREEN_HEIGHT 1024
#define SCREEN_WIDTH 1280
#define BALL_DIAMETER 40
#define PADDLE_WIDTH 40
#define PADDLE_HEIGHT 250
#define sev() __asm__("sev")
#define ARM1_STARTADR 0xFFFFFFF0
#define ARM1_BASEADDR 0x10080000
#define COMM_VAL (*(volatile unsigned long *)(0xFFFF0000))
#define DEBOUNCE_TICKS 18
volatile unsigned int ticks = 0;
int computer_side = 1;
int volume = 2;

// Parameter definitions
#define BTNS_DEVICE_ID XPAR_AXI_GPIO_1_DEVICE_ID
#define INTC_DEVICE_ID XPAR_PS7_SCUGIC_0_DEVICE_ID
// y
#define TMR_DEVICE_ID XPAR_TMRCTR_0_DEVICE_ID
// y
#define INTC_GPIO_INTERRUPT_ID XPAR_FABRIC_AXI_GPIO_1_IP2INTC_IRPT_INTR

#define INTC_TMR_INTERRUPT_ID XPAR_FABRIC_AXI_TIMER_0_INTERRUPT_INTR

#define BTN_INT XGPIO_IR_CH1_MASK
#define TMR_LOAD 0xFFE00000

XGpio LEDInst, BTNInst;
XScuGic INTCInst;
XTmrCtr TMRInst;

static int btn_value;

int recordStatus;

volatile bool TIMER_INTR_FLG;
volatile bool BUTTON_C_FLG = false;
volatile bool BUTTON_D_FLG = false;
volatile bool BUTTON_U_FLG = false;
volatile bool BUTTON_R_FLG = false;
volatile bool BUTTON_L_FLG = false;
int NUM_BYTES_BUFFER = 5242880;
//----------------------------------------------------
// PROTOTYPE FUNCTIONS
//----------------------------------------------------
static void BTN_Intr_Handler(void *baseaddr_p);
static void TMR_Intr_Handler(void *baseaddr_p);
static int InterruptSystemSetup(XScuGic *XScuGicInstancePtr);
static int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr);
void pollButtonState();

//----------------------------------------------------
// INTERRUPT HANDLER FUNCTIONS
// - called by the timer, button interrupt, performs
// - LED flashing
//----------------------------------------------------

void BTN_Intr_Handler(void *InstancePtr) {
    // Disable GPIO interrupts
    XGpio_InterruptDisable(&BTNInst, BTN_INT);
    // Check if the interrupt came from our button
    if ((XGpio_InterruptGetStatus(&BTNInst) & BTN_INT) != BTN_INT) {
        return;
    }

    // Store the last time a press was accepted
    static unsigned int lastButtonTick = 0;
    if ((ticks - lastButtonTick) < DEBOUNCE_TICKS) {
        // If the time since the last accepted press is less than our debounce interval, ignore this interrupt.
        (void)XGpio_InterruptClear(&BTNInst, BTN_INT);
        XGpio_InterruptEnable(&BTNInst, BTN_INT);
        return;
    }
    lastButtonTick = ticks;

    // Read button value
    btn_value = XGpio_DiscreteRead(&BTNInst, 1);

    if (btn_value == 4) {
        BUTTON_L_FLG = true;
    } else if (btn_value == 2) {
        BUTTON_D_FLG = true;
    } else if (btn_value == 8) {
        BUTTON_R_FLG = true;
    } else if (btn_value == 16) {
        BUTTON_U_FLG = true;
    } else if (btn_value == 1) {
    	if (Xil_In32(0xFFFF5000) == 0) {
    		PAUSE = 1;
    	} else if (Xil_In32(0xFFFF5000) == 1) {
    		PAUSE = 0;
    	}
        BUTTON_C_FLG = true;
    }

    (void)XGpio_InterruptClear(&BTNInst, BTN_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
}

void TMR_Intr_Handler(void *data) {
    ticks++;
    pollButtonState();
    TIMER_INTR_FLG = true;
    XTmrCtr_Reset(&TMRInst, 0);
    XTmrCtr_Start(&TMRInst, 0);
}

void displayColourBlock(int *baseAddr, int xloc, int yloc, int diam, int colour) {
    for (int i = 0; i < SCREEN_HEIGHT; i++) {
        for (int j = 0; j < SCREEN_WIDTH; j++) {
            if (i > yloc && i < yloc + diam && j > xloc && j < xloc + diam) {
                baseAddr[i * SCREEN_WIDTH + j] = colour;
            }
        }
    }
}

int main() {
    Xil_DCacheDisable();
    xil_printf("Entering Main in core 0\r\n");
    int status;
    Xil_SetTlbAttributes(0x10080000, 0x14de2);
    Xil_Out32(ARM1_STARTADR, ARM1_BASEADDR);
    dmb();
    sev();
    int colours[5] = {WHITE, BLACK, RED, BLUE, GREEN};
    //----------------------------------------------------
    // INITIALIZE THE PERIPHERALS & SET DIRECTIONS OF GPIO
    //----------------------------------------------------
    // Initialise Push Buttons
    status = XGpio_Initialize(&BTNInst, BTNS_DEVICE_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;
    XGpio_SetDataDirection(&BTNInst, 1, 0xFF);

    //----------------------------------------------------
    // SETUP THE TIMER
    //----------------------------------------------------
    status = XTmrCtr_Initialize(&TMRInst, TMR_DEVICE_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;
    XTmrCtr_SetHandler(&TMRInst, (XTmrCtr_Handler)TMR_Intr_Handler, &TMRInst);
    XTmrCtr_SetResetValue(&TMRInst, 0, TMR_LOAD);
    XTmrCtr_SetOptions(&TMRInst, 0, XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION);

    // Initialize interrupt controller
    status = IntcInitFunction(INTC_DEVICE_ID, &TMRInst, &BTNInst);
    if (status != XST_SUCCESS) return XST_FAILURE;

    XTmrCtr_Start(&TMRInst, 0);

    int *image_buffer_pointer = (int *)0x00900000;
    int selectedBallColour = 0;
    int selectedPaddleColour = 0;
    int selectedSide = -1;

    int winner = 0;
    // menu flag, while menu is true, do menu stuff, while false, do game stuff
    *isMenu = 1;
    int state = 0;
    int volume = 1;
    int gameHistoryArr[6][2] = {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};
    int historyWriteback = 0;
    int playedGameOverSound = 0;
    Game currentGame;
    currentGame.setVolume(volume);
    while (1) {
        while (TIMER_INTR_FLG == false) {
            Xil_DCacheFlush();
        }
        if (*isMenu == 1) {
            switch (state) {
                case (0):  // main menu single player highlighted
                           // setup buttons to switch state??
                    memcpy(image_buffer_pointer, mainMenuSinglePlayer, NUM_BYTES_BUFFER);
					if (BUTTON_D_FLG || BUTTON_U_FLG || BUTTON_L_FLG || BUTTON_R_FLG) {
						PLAY_SOUND = 3;
					}
                    if (BUTTON_D_FLG) {
                        state = 1;
                    } else if (BUTTON_U_FLG) {
                        state = 4;
                    } else if (BUTTON_R_FLG) {
                        state = 15;
                        currentGame.setMode(1);
                    }
                    playedGameOverSound = 0;
                    break;
                case (1):  // main menu multi player highlighted
                    memcpy(image_buffer_pointer, mainMenuMultiPlayer, NUM_BYTES_BUFFER);
					if (BUTTON_D_FLG || BUTTON_U_FLG || BUTTON_L_FLG || BUTTON_R_FLG) {
						PLAY_SOUND = 3;
					}
                    if (BUTTON_D_FLG) {
                        state = 2;
                    } else if (BUTTON_U_FLG) {
                        state = 0;
                    } else if (BUTTON_R_FLG) {
                        state = 5;
                        currentGame.setMode(0);
                    }
                    break;
                case (2):  // main menu volume highlighted
                    memcpy(image_buffer_pointer, mainMenuVolume, NUM_BYTES_BUFFER);
				if (BUTTON_D_FLG) {
						PLAY_SOUND = 3;
                        state = 3;
                    } else if (BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 1;
                    } else if (BUTTON_R_FLG) {
                    	PLAY_SOUND = 3;
                        if (volume == 1) {
                            state = 8;
                        } else if (volume == 2) {
                            state = 9;
                        } else if (volume == 3) {
                            state = 10;
                        } else {
                            state = 11;
                        }
                    }
                    break;
                case (3):  // main menu game history highlighted
					memcpy(image_buffer_pointer, mainMenuGameHistory, NUM_BYTES_BUFFER);
                	if (BUTTON_D_FLG) {
                    	PLAY_SOUND = 3;
                        state = 4;
                    } else if (BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 2;
                    } else if (BUTTON_R_FLG) {
                        memcpy(image_buffer_pointer, gameHistory, NUM_BYTES_BUFFER);
                        PLAY_SOUND = 3;
                        for (int i = 0; i < 6; i++) {
                            draw_score_100x100(gameHistoryArr[i][0], 550, 300 + 120 * i, WHITE);
                            draw_score_100x100(gameHistoryArr[i][1], 850, 300 + 120 * i, WHITE);
                        }
                        state = (12);
                    }
                    break;
                case (4):  // main menu colour select highlighted
                    memcpy(image_buffer_pointer, mainMenuColourSelect, NUM_BYTES_BUFFER);
                    if (BUTTON_D_FLG) {
                    	PLAY_SOUND = 3;
                        state = 0;
                    } else if (BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 3;

                    } else if (BUTTON_R_FLG) {
                    	PLAY_SOUND = 3;
                        state = 13;
                        memcpy(image_buffer_pointer, ballColour, NUM_BYTES_BUFFER);
                        displayColourBlock(image_buffer_pointer, 700, 300, 200, colours[selectedBallColour % 5]);
                        displayColourBlock(image_buffer_pointer, 700, 550, 200, colours[selectedPaddleColour % 5]);
                    }
                    break;
                case (5):  // select difficulty easy(both for single and multiplayer)
                    memcpy(image_buffer_pointer, difficultyEasy, NUM_BYTES_BUFFER);
                    if (BUTTON_D_FLG) {
                    	PLAY_SOUND = 3;
                        state = 6;
                    } else if (BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 7;
                    } else if (BUTTON_R_FLG) {
                        // start game easy
                        memcpy(image_buffer_pointer, background, NUM_BYTES_BUFFER);
                        PLAY_SOUND = 3;
                        currentGame.setDifficulty(0);
                        *isMenu = 0;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 0;
                    }
                    break;
                case (6):  // select difficulty medium
                    memcpy(image_buffer_pointer, difficultyMedium, NUM_BYTES_BUFFER);
                    if (BUTTON_D_FLG) {
                    	PLAY_SOUND = 3;
                        state = 7;
                    } else if (BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 5;
                    } else if (BUTTON_R_FLG) {
                        // start game medium
                        memcpy(image_buffer_pointer, background, NUM_BYTES_BUFFER);
                        PLAY_SOUND = 3;
                        currentGame.setDifficulty(1);
                        *isMenu = false;

                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 0;
                    }
                    break;
                case (7):  // select difficulty hard
                    memcpy(image_buffer_pointer, difficultyHard, NUM_BYTES_BUFFER);
                    if (BUTTON_D_FLG) {
                    	PLAY_SOUND = 3;
                        state = 5;
                    } else if (BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 6;
                    } else if (BUTTON_R_FLG) {
                        // start game hard
                        memcpy(image_buffer_pointer, background, NUM_BYTES_BUFFER);
                        PLAY_SOUND = 3;
                        currentGame.setDifficulty(2);
                        *isMenu = false;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 0;
                    }
                    break;
                case (8):  // volume 1
                    memcpy(image_buffer_pointer, volume1, NUM_BYTES_BUFFER);
                    if (BUTTON_C_FLG) {
                        state = 9;
                        volume = 2;
                        currentGame.setVolume(volume);
                        PLAY_SOUND = 3;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 2;
                    }
                    break;
                case (9):  // volume 2
                    memcpy(image_buffer_pointer, volume2, NUM_BYTES_BUFFER);
                    if (BUTTON_C_FLG) {
                        state = 10;
                        volume = 3;
                        currentGame.setVolume(volume);
                        PLAY_SOUND = 3;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 2;
                    }
                    break;
                case (10):  // volume 3
                    memcpy(image_buffer_pointer, volume3, NUM_BYTES_BUFFER);
                    if (BUTTON_C_FLG) {
                        state = 11;
                        volume = 4;
                        currentGame.setVolume(volume);
                        PLAY_SOUND = 3;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 2;
                    }
                    break;
                case (11):  // volume 4
                    memcpy(image_buffer_pointer, volume4, NUM_BYTES_BUFFER);
                    if (BUTTON_C_FLG) {
                        state = 8;
                        volume = 1;
                        currentGame.setVolume(volume);
                        PLAY_SOUND = 3;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 2;
                    }
                    break;
                case (12):  // game history
                    if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 3;
                    }
                    break;
                case (13):  // select ball colour
                    if (BUTTON_C_FLG) {
                        selectedBallColour++;
                        displayColourBlock(image_buffer_pointer, 700, 300, 200, colours[selectedBallColour % 5]);
                        PLAY_SOUND = 3;
                        // cycle ball colour and save choice in register
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 4;
                        *vgaPaddleColour = colours[selectedPaddleColour % 5];
                        *vgaBallColour = colours[selectedBallColour % 5];
                    } else if (BUTTON_D_FLG || BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 14;
                        memcpy(image_buffer_pointer, paddleColour, NUM_BYTES_BUFFER);
                        displayColourBlock(image_buffer_pointer, 700, 300, 200, colours[selectedBallColour % 5]);
                        displayColourBlock(image_buffer_pointer, 700, 550, 200, colours[selectedPaddleColour % 5]);
                    }
                    break;
                case (14):  // select paddle colour
                    if (BUTTON_C_FLG) {
                    	PLAY_SOUND = 3;
                        selectedPaddleColour++;
                        displayColourBlock(image_buffer_pointer, 700, 550, 200, colours[selectedPaddleColour % 5]);
                        // cycle paddle colour and store choice in register
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 4;
                        *vgaPaddleColour = colours[selectedPaddleColour % 5];
                        *vgaBallColour = colours[selectedBallColour % 5];
                    } else if (BUTTON_D_FLG || BUTTON_U_FLG) {
                        state = 13;
                        memcpy(image_buffer_pointer, ballColour, NUM_BYTES_BUFFER);
                        PLAY_SOUND = 3;
                        displayColourBlock(image_buffer_pointer, 700, 300, 200, colours[selectedBallColour % 5]);
                        displayColourBlock(image_buffer_pointer, 700, 550, 200, colours[selectedPaddleColour % 5]);
                    }
                    break;
                case (15):  // play as left side
                    memcpy(image_buffer_pointer, selectLeft, NUM_BYTES_BUFFER);
                    if (BUTTON_R_FLG) {
                    	PLAY_SOUND = 3;
                        currentGame.setComputerSide(1);
                        state = 5;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 0;
                    } else if (BUTTON_D_FLG || BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 16;
                    }
                    break;
                case (16):  // play as right side
                    memcpy(image_buffer_pointer, selectRight, NUM_BYTES_BUFFER);
                    if (BUTTON_R_FLG) {
                    	PLAY_SOUND = 3;
                        currentGame.setComputerSide(0);
                        state = 5;
                    } else if (BUTTON_L_FLG) {
                    	PLAY_SOUND = 3;
                        state = 0;
                    } else if (BUTTON_D_FLG || BUTTON_U_FLG) {
                    	PLAY_SOUND = 3;
                        state = 15;
                    }
                    break;
                case (17):
							if (BUTTON_D_FLG || BUTTON_U_FLG || BUTTON_L_FLG || BUTTON_R_FLG) {
								PLAY_SOUND = 3;
							}
                    if (BUTTON_C_FLG) {
                        state = 0;
                    }
                	if (playedGameOverSound == 0) {
                		PLAY_SOUND = 0;
                		playedGameOverSound = 1;
                	}
                    break;
                default:
                    break;
            }
            BUTTON_R_FLG = false;
            BUTTON_U_FLG = false;
            BUTTON_D_FLG = false;
            BUTTON_L_FLG = false;
            BUTTON_C_FLG = false;
        }
        if (*isMenu == 0) {
            while (Xil_In32(0xFFFF5000) == 1) {

            }
            BUTTON_C_FLG = false;
            currentGame.paddleMovementHandler();
            winner = currentGame.updateGameState();
            if (winner != 0) {
                *isMenu = 1;
                gameHistoryArr[historyWriteback % 6][0] = currentGame.getPlayerOneScore();
                gameHistoryArr[historyWriteback % 6][1] = currentGame.getPlayerTwoScore();

                if (currentGame.getPlayerOneScore() > currentGame.getPlayerTwoScore()) {
                    memcpy(image_buffer_pointer, playerOneWin, NUM_BYTES_BUFFER);

                    draw_score_100x100(gameHistoryArr[historyWriteback][0], 350, 600, WHITE);
                    draw_score_100x100(gameHistoryArr[historyWriteback][1], 675, 600, WHITE);
                } else {
                    memcpy(image_buffer_pointer, playerTwoWin, NUM_BYTES_BUFFER);
                    draw_score_100x100(gameHistoryArr[historyWriteback][0], 350, 600, WHITE);
                    draw_score_100x100(gameHistoryArr[historyWriteback][1], 675, 600, WHITE);
                }
                state = 17;
                currentGame.resetScore();
                historyWriteback++;
            }
        }
        TIMER_INTR_FLG = false;
    }
    return 0;
}

//----------------------------------------------------
// INITIAL SETUP FUNCTIONS
//----------------------------------------------------

int InterruptSystemSetup(XScuGic *XScuGicInstancePtr) {
    // Enable interrupt
    XGpio_InterruptEnable(&BTNInst, BTN_INT);
    XGpio_InterruptGlobalEnable(&BTNInst);

    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 XScuGicInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

int IntcInitFunction(u16 DeviceId, XTmrCtr *TmrInstancePtr, XGpio *GpioInstancePtr) {
    XScuGic_Config *IntcConfig;
    int status;

    // Interrupt controller initialisation
    IntcConfig = XScuGic_LookupConfig(DeviceId);
    status = XScuGic_CfgInitialize(&INTCInst, IntcConfig, IntcConfig->CpuBaseAddress);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Call to interrupt setup
    status = InterruptSystemSetup(&INTCInst);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Connect GPIO interrupt to handler
    status = XScuGic_Connect(&INTCInst,
                             INTC_GPIO_INTERRUPT_ID,
                             (Xil_ExceptionHandler)BTN_Intr_Handler,
                             (void *)GpioInstancePtr);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Connect timer interrupt to handler
    status = XScuGic_Connect(&INTCInst,
                             INTC_TMR_INTERRUPT_ID,
                             (Xil_ExceptionHandler)TMR_Intr_Handler,
                             (void *)TmrInstancePtr);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Enable GPIO interrupts interrupt
    XGpio_InterruptEnable(GpioInstancePtr, 1);
    XGpio_InterruptGlobalEnable(GpioInstancePtr);

    // Enable GPIO and timer interrupts in the controller
    XScuGic_Enable(&INTCInst, INTC_GPIO_INTERRUPT_ID);

    XScuGic_Enable(&INTCInst, INTC_TMR_INTERRUPT_ID);

    return XST_SUCCESS;
}

void pollButtonState() {
    // Update paddle movement based on button value:
    // Left button (val == 4): move left paddle (player 1) up (-1)
    // Bottom button (val == 2): move left paddle (player 1) down (+1)
    // Top button (val == 8): move right paddle (player 2) up (-1)
    // Right button (val == 16): move right paddle (player 2) down (+1)

    int btn_value = XGpio_DiscreteRead(&BTNInst, 1);
    if (btn_value & 4) {
        PLAYER_1_VELOCITY = -PADDLE_SPEED;
    } else if (btn_value & 2) {
        PLAYER_1_VELOCITY = PADDLE_SPEED;
    } else {
        PLAYER_1_VELOCITY = 0;
    }

    if (btn_value & 8) {
        PLAYER_2_VELOCITY = PADDLE_SPEED;
    } else if (btn_value & 16) {
        PLAYER_2_VELOCITY = -PADDLE_SPEED;
    } else {
        PLAYER_2_VELOCITY = 0;
    }
}
