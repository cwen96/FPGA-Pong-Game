/*
 * ip_functions.c
 *
 * Contains all functions which pertain to setup and use of IP periperals.
 */

#include "adventures_with_ip.h"

/* ---------------------------------------------------------------------------- *
 * 								audio_stream()									*
 * ---------------------------------------------------------------------------- *
 * This function performs audio loopback streaming by sampling the input audio
 * from the codec and then immediately passing the sample to the output of the
 * codec.
 *
 * The main menu can be accessed by entering 'q' on the keyboard.
 * ---------------------------------------------------------------------------- */
void audio_stream() {
    u32 in_left, in_right;

    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        // Read audio input from codec
        in_left = Xil_In32(I2S_DATA_RX_L_REG);
        in_right = Xil_In32(I2S_DATA_RX_R_REG);
        // Write audio output to codec
        Xil_Out32(I2S_DATA_TX_L_REG, in_left);
        Xil_Out32(I2S_DATA_TX_R_REG, in_right);
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q')
        menu();
    else
        audio_stream();
}  // audio_stream()

/* ---------------------------------------------------------------------------- *
 * 								gpio_initi()									*
 * ---------------------------------------------------------------------------- *
 * Initialises the GPIO driver for the push buttons and switches.
 * ---------------------------------------------------------------------------- */
unsigned char gpio_init() {
    int status;

    // Initialise Push Buttons
    status = XGpio_Initialize(&Gpio, BUTTON_SWITCH_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Set all switches direction to inputs
    XGpio_SetDataDirection(&Gpio, SWITCH_CHANNEL, 0xFF);

    // Set all buttons direction to inputs
    XGpio_SetDataDirection(&Gpio, BUTTON_CHANNEL, 0xFF);

    return XST_SUCCESS;
}

/* ---------------------------------------------------------------------------- *
 * 								lab_test()									    *
 * ---------------------------------------------------------------------------- *
Audio: This task will have you build off of the audio tutorial so that you are
able to record sounds to memory and play them back over a speaker.

You should be able to start and stop a recording (up to a fixed time length) as
well as play it back with user input (key press/push button/etc).

Be prepared to answer questions on your final implementation and design choices.

Note: Your user interface (push buttons/switches/key press/etc.) will need to
use interrupts to get full marks and not polling.

Remember, the use of interrupts is a requirement for your final project, so it
would be good if at least one of you could use this as the basis of for one of your
project milestones to help you succeed with your final project deliverables.
 * ---------------------------------------------------------------------------- */
int lab_test() {
	u32 in_left, in_right;
	if (interruptInit == 0) {
		// Initialize interrupt controller
		int status = IntcInitFunction(INTC_DEVICE_ID, &Gpio);
		if (status != XST_SUCCESS) return XST_FAILURE;
		interruptInit = 1;
	}

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue. */
    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        if (recordStatus == 1) {
        	if (prevStatus != 1) {
        		xil_printf("Recording audio...\r\n");
        		prevStatus = 1;
        	}
            // Read audio input from codec
            in_left = Xil_In32(I2S_DATA_RX_L_REG);
            in_right = Xil_In32(I2S_DATA_RX_R_REG);
        } else if (recordStatus == 2) {
        	if (prevStatus != 2) {
        		xil_printf("Playing audio...\r\n");
        		 prevStatus = 2;
        	}
            // Write audio output to codec
        	//put delay before each play
            Xil_Out32(I2S_DATA_TX_L_REG, in_left);
            Xil_Out32(I2S_DATA_TX_R_REG, in_right);
        }
    }

    /* If input from the terminal is 'q', then return to menu.
         * Else, continue streaming. */
	if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q')
		menu();
	else
		lab_test();
	return XST_SUCCESS;
}

int IntcInitFunction(u16 DeviceId, XGpio *GpioInstancePtr) {
    XScuGic_Config *IntcConfig;
    int status;

    // Interrupt controller initialisation
    IntcConfig = XScuGic_LookupConfig(DeviceId);
    status = XScuGic_CfgInitialize(&INTCInst, IntcConfig, IntcConfig->CpuBaseAddress);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Call to interrupt setup
    status = InterruptSystemSetup(&INTCInst);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Connect GPIO interrupt to handler
    status = XScuGic_Connect(&INTCInst,
                             INTC_GPIO_INTERRUPT_ID,
                             (Xil_ExceptionHandler)BTN_Intr_Handler,
                             (void *)GpioInstancePtr);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Enable GPIO interrupts interrupt
    XGpio_InterruptEnable(GpioInstancePtr, 1);
    XGpio_InterruptGlobalEnable(GpioInstancePtr);

    // Enable GPIO and timer interrupts in the controller
    XScuGic_Enable(&INTCInst, INTC_GPIO_INTERRUPT_ID);

    return XST_SUCCESS;
}

//----------------------------------------------------
// INTERRUPT INITIAL SETUP FUNCTIONS
//----------------------------------------------------
int InterruptSystemSetup(XScuGic *XScuGicInstancePtr) {
    // Enable interrupt
    XGpio_InterruptEnable(&Gpio, BTN_INT);
    XGpio_InterruptGlobalEnable(&Gpio);

    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 XScuGicInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

//----------------------------------------------------
// INTERRUPT HANDLER FUNCTIONS
// Called by the timer, button interrupt, performs
// audio recording and playback
//----------------------------------------------------
void BTN_Intr_Handler(void *InstancePtr) {
    // Disable GPIO interrupts
    XGpio_InterruptDisable(&Gpio, BTN_INT);
    // Ignore additional button presses
    if ((XGpio_InterruptGetStatus(&Gpio) & BTN_INT) !=
        BTN_INT) {
        return;
    }
    btn_value = XGpio_DiscreteRead(&Gpio, 1);

    // Start recording when bottom button is pressed
    if (btn_value == 2) {
        recordStatus = 1;
    } else if (btn_value == 1) {  // Play recording when middle button is pressed
        recordStatus = 2;
    }

    (void)XGpio_InterruptClear(&Gpio, BTN_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&Gpio, BTN_INT);
}
