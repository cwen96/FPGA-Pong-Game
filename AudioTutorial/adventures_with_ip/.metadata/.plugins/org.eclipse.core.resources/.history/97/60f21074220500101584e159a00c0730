/*
 * ip_functions.c
 *
 * Contains all functions which pertain to setup and use of IP periperals.
 */

#include "adventures_with_ip.h"
#include "audioSD.h"

/* ---------------------------------------------------------------------------- *
 * 								audio_stream()									*
 * ---------------------------------------------------------------------------- *
 * This function performs audio loopback streaming by sampling the input audio
 * from the codec and then immediately passing the sample to the output of the
 * codec.
 *
 * The main menu can be accessed by entering 'q' on the keyboard.
 * ---------------------------------------------------------------------------- */
void audio_stream() {
    u32 in_left, in_right;

    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        // Read audio input from codec
        in_left = Xil_In32(I2S_DATA_RX_L_REG);
        in_right = Xil_In32(I2S_DATA_RX_R_REG);
        // Write audio output to codec
        Xil_Out32(I2S_DATA_TX_L_REG, in_left);
        Xil_Out32(I2S_DATA_TX_R_REG, in_right);
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q')
        menu();
    else
        audio_stream();
}  // audio_stream()

/* ---------------------------------------------------------------------------- *
 * 								gpio_initi()									*
 * ---------------------------------------------------------------------------- *
 * Initialises the GPIO driver for the push buttons and switches.
 * ---------------------------------------------------------------------------- */
unsigned char gpio_init() {
    int status;

    // Initialise Push Buttons
    status = XGpio_Initialize(&Gpio, BUTTON_SWITCH_ID);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Set all switches direction to inputs
    XGpio_SetDataDirection(&Gpio, SWITCH_CHANNEL, 0xFF);

    // Set all buttons direction to inputs
    XGpio_SetDataDirection(&Gpio, BUTTON_CHANNEL, 0xFF);

    interruptInit = 0;
    prevStatus = 0;

    return XST_SUCCESS;
}

/* ---------------------------------------------------------------------------- *
 * 								lab_test()									    *
 * ---------------------------------------------------------------------------- *
Audio: This task will have you build off of the audio tutorial so that you are
able to record sounds to memory and play them back over a speaker.

You should be able to start and stop a recording (up to a fixed time length) as
well as play it back with user input (key press/push button/etc).

Be prepared to answer questions on your final implementation and design choices.

Note: Your user interface (push buttons/switches/key press/etc.) will need to
use interrupts to get full marks and not polling.

Remember, the use of interrupts is a requirement for your final project, so it
would be good if at least one of you could use this as the basis of for one of your
project milestones to help you succeed with your final project deliverables.
 * ---------------------------------------------------------------------------- */
int lab_test() {

    int center_status = 0;
    int bot_status = 0;
    int left_status = 0;
    int up_status = 0;
    int right_status = 0;

    if (interruptInit == 0) {
        // Initialize interrupt controller
        int status = IntcInitFunction(INTC_DEVICE_ID, &Gpio);
        if (status != XST_SUCCESS) {
            return XST_FAILURE;
        }

        loadAudioSD();
        interruptInit = 1;
    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue. */
    while (!XUartPs_IsReceiveData(UART_BASEADDR)) {
        if (btnStatus == 1) {
            if (center_status == 0) {
                xil_printf("Playing center button\r\n");
                playWavFile("cent.wav");
                center_status = 1;
            }
            right_status = 0;
            bot_status = 0;
            left_status = 0;
        }
        else if (btnStatus == 2) {
            if (bot_status == 0) {
                xil_printf("Playing bottom button\r\n");
                playWavFile("bot.wav");
                bot_status = 1;
            }
            left_status = 0;
            up_status = 0;
            right_status = 0;
        }
        else if (btnStatus == 3) {
            if (left_status == 0) {
                xil_printf("Playing left button\r\n");
                playWavFile("left.wav");
                left_status = 1;
            }
            up_status = 0;
            right_status = 0;
            bot_status = 0;
        }
        else if (btnStatus == 4) {
            if (up_status == 0) {
                xil_printf("Playing up button\r\n");
                playWavFile("up.wav");
                up_status = 1;
            }
            right_status = 0;
            bot_status = 0;
            left_status = 0;
        }
        else if (btnStatus == 5) {
            if (right_status == 0) {
                xil_printf("Playing right\r\n");
                playWavFile("right.wav");
                right_status = 1;
            }
            bot_status = 0;
            left_status = 0;
            up_status = 0;
        }

    }

    /* If input from the terminal is 'q', then return to menu.
     * Else, continue streaming. */
    if (XUartPs_ReadReg(UART_BASEADDR, XUARTPS_FIFO_OFFSET) == 'q') {
        menu();
    } else {
        lab_test();
    }
    return XST_SUCCESS;
}

int IntcInitFunction(u16 DeviceId, XGpio *GpioInstancePtr) {
    XScuGic_Config *IntcConfig;
    int status;

    // Interrupt controller initialisation
    IntcConfig = XScuGic_LookupConfig(DeviceId);
    status = XScuGic_CfgInitialize(&INTCInst, IntcConfig, IntcConfig->CpuBaseAddress);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Call to interrupt setup
    status = InterruptSystemSetup(&INTCInst);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Connect GPIO interrupt to handler
    status = XScuGic_Connect(&INTCInst,
                             INTC_GPIO_INTERRUPT_ID,
                             (Xil_ExceptionHandler)BTN_Intr_Handler,
                             (void *)GpioInstancePtr);
    if (status != XST_SUCCESS) return XST_FAILURE;

    // Enable GPIO interrupts interrupt
    XGpio_InterruptEnable(GpioInstancePtr, 1);
    XGpio_InterruptGlobalEnable(GpioInstancePtr);

    // Enable GPIO and timer interrupts in the controller
    XScuGic_Enable(&INTCInst, INTC_GPIO_INTERRUPT_ID);

    return XST_SUCCESS;
}

//----------------------------------------------------
// INTERRUPT INITIAL SETUP FUNCTIONS
//----------------------------------------------------
int InterruptSystemSetup(XScuGic *XScuGicInstancePtr) {
    // Enable interrupt
    XGpio_InterruptEnable(&Gpio, BTN_INT);
    XGpio_InterruptGlobalEnable(&Gpio);

    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 XScuGicInstancePtr);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

//----------------------------------------------------
// INTERRUPT HANDLER FUNCTIONS
// Called by the timer, button interrupt, performs
// audio recording and playback
//----------------------------------------------------
void BTN_Intr_Handler(void *InstancePtr) {
    // Disable GPIO interrupts
    XGpio_InterruptDisable(&Gpio, BTN_INT);
    // Ignore additional button presses
    if ((XGpio_InterruptGetStatus(&Gpio) & BTN_INT) !=
        BTN_INT) {
        return;
    }
    btn_value = XGpio_DiscreteRead(&Gpio, 1);

    // Center button
    if (btn_value == 1) {
        btnStatus = 1;
    } else if (btn_value == 2) {  // Bottom button
        btnStatus = 2;
    } else if (btn_value == 4) { // Left button
    	btnStatus = 3;
    } else if (btn_value == 8) { // Up button
    	btnStatus = 4;
    } else if (btn_value == 16) { // Right button
    	btnStatus = 5;
    }

    (void)XGpio_InterruptClear(&Gpio, BTN_INT);
    // Enable GPIO interrupts
    XGpio_InterruptEnable(&Gpio, BTN_INT);
}
